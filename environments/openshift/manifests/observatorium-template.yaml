apiVersion: v1
kind: Template
metadata:
  name: observatorium
objects:
- apiVersion: v1
  data:
    client_id: ""
    client_secret: ""
    oidc_issuer: ""
  kind: Secret
  metadata:
    labels:
      k8s-app: telemeter-server
    name: telemeter-server
    namespace: ${NAMESPACE}
  type: Opaque
- apiVersion: v1
  kind: Service
  metadata:
    annotations:
      service.alpha.openshift.io/serving-cert-secret-name: telemeter-server-shared
    labels:
      k8s-app: telemeter-server
    name: telemeter-server
    namespace: ${NAMESPACE}
  spec:
    clusterIP: None
    ports:
    - name: external
      port: 8443
      targetPort: external
    - name: internal
      port: 8081
      targetPort: internal
    - name: cluster
      port: 8082
      targetPort: cluster
    selector:
      k8s-app: telemeter-server
- apiVersion: v1
  kind: ServiceAccount
  metadata:
    name: telemeter-server
    namespace: ${NAMESPACE}
- apiVersion: monitoring.coreos.com/v1
  kind: ServiceMonitor
  metadata:
    labels:
      endpoint: metrics
      k8s-app: telemeter-server
    name: telemeter-server
    namespace: ${NAMESPACE}
  spec:
    endpoints:
    - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
      interval: 30s
      port: internal
      scheme: https
      tlsConfig:
        caFile: /var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt
        serverName: telemeter-server.${NAMESPACE}.svc
    jobLabel: k8s-app
    selector:
      matchLabels:
        k8s-app: telemeter-server
- apiVersion: monitoring.coreos.com/v1
  kind: ServiceMonitor
  metadata:
    labels:
      endpoint: federate
      k8s-app: telemeter-server
    name: telemeter-server-federate
    namespace: ${NAMESPACE}
  spec:
    endpoints:
    - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
      honorLabels: true
      interval: 15s
      params:
        match[]:
        - '{__name__=~".*"}'
      path: /federate
      port: internal
      scheme: https
      tlsConfig:
        caFile: /var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt
        serverName: telemeter-server.${NAMESPACE}.svc
    jobLabel: k8s-app
    selector:
      matchLabels:
        k8s-app: telemeter-server
- apiVersion: apps/v1beta2
  kind: StatefulSet
  metadata:
    name: telemeter-server
    namespace: ${NAMESPACE}
  spec:
    podManagementPolicy: Parallel
    replicas: 10
    selector:
      matchLabels:
        k8s-app: telemeter-server
    serviceName: telemeter-server
    template:
      metadata:
        labels:
          k8s-app: telemeter-server
      spec:
        containers:
        - command:
          - /usr/bin/telemeter-server
          - --join=telemeter-server
          - --name=$(NAME)
          - --listen=0.0.0.0:8443
          - --listen-internal=0.0.0.0:8081
          - --listen-cluster=0.0.0.0:8082
          - --shared-key=/etc/pki/service/tls.key
          - --tls-key=/etc/pki/service/tls.key
          - --tls-crt=/etc/pki/service/tls.crt
          - --internal-tls-key=/etc/pki/service/tls.key
          - --internal-tls-crt=/etc/pki/service/tls.crt
          - --authorize=${AUTHORIZE_URL}
          - --oidc-issuer=$(OIDC_ISSUER)
          - --client-id=$(CLIENT_ID)
          - --client-secret=$(CLIENT_SECRET)
          - --whitelist={__name__=~"cluster:usage:.*"}
          - --whitelist={__name__="up"}
          - --whitelist={__name__="cluster_version"}
          - --whitelist={__name__="cluster_version_available_updates"}
          - --whitelist={__name__="cluster_operator_up"}
          - --whitelist={__name__="cluster_operator_conditions"}
          - --whitelist={__name__="cluster_version_payload"}
          - --whitelist={__name__="cluster_installer"}
          - --whitelist={__name__="cluster_infrastructure_provider"}
          - --whitelist={__name__="cluster_feature_set"}
          - --whitelist={__name__="node_uname_info"}
          - --whitelist={__name__="instance:etcd_object_counts:sum"}
          - --whitelist={__name__="alerts",alertstate="firing"}
          - --whitelist={__name__="code:apiserver_request_count:rate:sum"}
          - --whitelist={__name__="cluster:capacity_cpu_cores:sum"}
          - --whitelist={__name__="cluster:capacity_memory_bytes:sum"}
          - --whitelist={__name__="cluster:cpu_usage_cores:sum"}
          - --whitelist={__name__="cluster:memory_usage_bytes:sum"}
          - --whitelist={__name__="openshift:cpu_usage_cores:sum"}
          - --whitelist={__name__="openshift:memory_usage_bytes:sum"}
          - --whitelist={__name__="workload:cpu_usage_cores:sum"}
          - --whitelist={__name__="workload:memory_usage_bytes:sum"}
          - --whitelist={__name__="cluster:virt_platform_nodes:sum"}
          - --whitelist={__name__="cluster:node_instance_type_count:sum"}
          - --whitelist={__name__="cnv:vmi_status_running:count"}
          - --whitelist={__name__="node_role_os_version_machine:cpu_capacity_cores:sum"}
          - --whitelist={__name__="node_role_os_version_machine:cpu_capacity_sockets:sum"}
          - --whitelist={__name__="subscription_sync_total"}
          - --whitelist={__name__="csv_succeeded"}
          - --whitelist={__name__="csv_abnormal"}
          - --whitelist={__name__="ceph_cluster_total_bytes"}
          - --whitelist={__name__="ceph_cluster_total_used_raw_bytes"}
          - --whitelist={__name__="ceph_health_status"}
          - --whitelist={__name__="job:ceph_osd_metadata:count"}
          - --whitelist={__name__="job:kube_pv:count"}
          - --whitelist={__name__="job:ceph_pools_iops:total"}
          - --whitelist={__name__="job:ceph_pools_iops_bytes:total"}
          - --whitelist={__name__="job:ceph_versions_running:count"}
          - --whitelist={__name__="job:noobaa_total_unhealthy_buckets:sum"}
          - --whitelist={__name__="job:noobaa_bucket_count:sum"}
          - --whitelist={__name__="job:noobaa_total_object_count:sum"}
          - --whitelist={__name__="noobaa_accounts_num"}
          - --whitelist={__name__="noobaa_total_usage"}
          - --whitelist={__name__="console_url"}
          - --whitelist={__name__="cluster:network_attachment_definition_instances:max"}
          - --whitelist={__name__="cluster:network_attachment_definition_enabled_instance_up:max"}
          - --whitelist={__name__="insightsclient_request_send_total"}
          - --elide-label=prometheus_replica
          - --token-expire-seconds=3600
          - --forward-url=${TELEMETER_FORWARD_URL}
          env:
          - name: NAME
            valueFrom:
              fieldRef:
                fieldPath: metadata.name
          - name: OIDC_ISSUER
            valueFrom:
              secretKeyRef:
                key: oidc_issuer
                name: telemeter-server
          - name: CLIENT_SECRET
            valueFrom:
              secretKeyRef:
                key: client_secret
                name: telemeter-server
          - name: CLIENT_ID
            valueFrom:
              secretKeyRef:
                key: client_id
                name: telemeter-server
          image: ${IMAGE}:${IMAGE_TAG}
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8443
              scheme: HTTPS
          name: telemeter-server
          ports:
          - containerPort: 8443
            name: external
          - containerPort: 8081
            name: internal
          - containerPort: 8082
            name: cluster
          readinessProbe:
            httpGet:
              path: /healthz/ready
              port: 8443
              scheme: HTTPS
          resources:
            limits:
              cpu: ${TELEMETER_SERVER_CPU_LIMIT}
              memory: ${TELEMETER_SERVER_MEMORY_LIMIT}
            requests:
              cpu: ${TELEMETER_SERVER_CPU_REQUEST}
              memory: ${TELEMETER_SERVER_MEMORY_REQUEST}
          volumeMounts:
          - mountPath: /etc/pki/service
            name: telemeter-server-tls
            readOnly: false
        serviceAccountName: telemeter-server
        volumes:
        - name: secret-telemeter-server
          secret:
            secretName: telemeter-server
        - name: telemeter-server-tls
          secret:
            secretName: telemeter-server-shared
- apiVersion: v1
  data:
    nginx.conf: |
      daemon off;
      worker_processes 1;
      error_log /dev/stderr;
      pid /tmp/nginx.pid;

      events {
          worker_connections 1024;
      }

      http {
        log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                          '$status $body_bytes_sent "$http_referer" '
                          '"$http_user_agent" "$http_x_forwarded_for"';

        server {
          listen *:8080;
          server_name _;
          access_log  /dev/stdout  main;
          error_log /dev/stderr;

          location / {
            proxy_set_header THANOS-TENANT FB870BF3-9F3A-44FF-9BF7-D7A047A52F43;
            proxy_pass http://thanos-receive.${NAMESPACE}.svc.cluster.local:19291;
          }
        }
      }
  kind: ConfigMap
  metadata:
    labels:
      app.kubernetes.io/instance: remote-write-proxy
      app.kubernetes.io/name: nginx
      app.kubernetes.io/part-of: prometheus-ams
    name: prometheus-remote-write-proxy-config
    namespace: ${NAMESPACE}
- apiVersion: apps/v1
  kind: Deployment
  metadata:
    labels:
      app.kubernetes.io/instance: remote-write-proxy
      app.kubernetes.io/name: nginx
      app.kubernetes.io/part-of: prometheus-ams
    name: prometheus-remote-write-proxy
    namespace: ${NAMESPACE}
  spec:
    replicas: 1
    selector:
      matchLabels:
        app.kubernetes.io/instance: remote-write-proxy
        app.kubernetes.io/name: nginx
    template:
      metadata:
        labels:
          app.kubernetes.io/instance: remote-write-proxy
          app.kubernetes.io/name: nginx
      spec:
        containers:
        - args:
          - -c
          - /config/nginx.conf
          command:
          - nginx
          image: ${PROMETHEUS_AMS_REMOTE_WRITE_PROXY_IMAGE}:${PROMETHEUS_AMS_REMOTE_WRITE_PROXY_VERSION}
          name: remote-write-proxy
          ports:
          - containerPort: 8080
            name: http
          resources:
            limits:
              cpu: 100m
              memory: 64Mi
            requests:
              cpu: 50m
              memory: 16Mi
          volumeMounts:
          - mountPath: /config
            name: prometheus-remote-write-proxy-config
            readOnly: true
        volumes:
        - configMap:
            name: prometheus-remote-write-proxy-config
          name: prometheus-remote-write-proxy-config
- apiVersion: monitoring.coreos.com/v1
  kind: Prometheus
  metadata:
    labels:
      app.kubernetes.io/instance: ams
      app.kubernetes.io/name: prometheus
      app.kubernetes.io/part-of: prometheus-ams
      prometheus: ams
    name: ams
    namespace: ${NAMESPACE}
  spec:
    baseImage: ${PROMETHEUS_AMS_IMAGE}
    containers: []
    remoteWrite:
    - url: http://prometheus-ams-remote-write-proxy.${NAMESPACE}.svc.cluster.local:8080/api/v1/receive
      writeRelabelConfigs:
      - action: keep
        regex: subscription_labels
        sourceLabels:
        - __name__
    replicas: 1
    resources:
      limits:
        cpu: ${PROMETHEUS_AMS_CPU_LIMIT}
        memory: ${PROMETHEUS_AMS_MEMORY_LIMIT}
      requests:
        cpu: ${PROMETHEUS_AMS_CPU_REQUEST}
        memory: ${PROMETHEUS_AMS_MEMORY_REQUEST}
    ruleSelector:
      matchLabels:
        prometheus: ams
        role: alert-rules
    securityContext: {}
    serviceAccount: prometheus-telemeter
    serviceAccountName: prometheus-telemeter
    serviceMonitorSelector:
      matchLabels:
        prometheus: ams
    version: ${PROMETHEUS_AMS_IMAGE_TAG}
- apiVersion: v1
  kind: Service
  metadata:
    labels:
      app.kubernetes.io/instance: remote-write-proxy
      app.kubernetes.io/name: nginx
      app.kubernetes.io/part-of: prometheus-ams
    name: prometheus-ams-remote-write-proxy
    namespace: ${NAMESPACE}
  spec:
    ports:
    - name: http
      port: 8080
      targetPort: http
    selector:
      app.kubernetes.io/instance: remote-write-proxy
      app.kubernetes.io/name: nginx
- apiVersion: v1
  kind: Service
  metadata:
    labels:
      app.kubernetes.io/instance: ams
      app.kubernetes.io/name: prometheus
      app.kubernetes.io/part-of: prometheus-ams
      prometheus: ams
    name: prometheus-ams
    namespace: ${NAMESPACE}
  spec:
    ports:
    - name: web
      port: 9090
      targetPort: web
    selector:
      prometheus: ams
    sessionAffinity: ClientIP
- apiVersion: monitoring.coreos.com/v1
  kind: ServiceMonitor
  metadata:
    labels:
      app.kubernetes.io/instance: ams
      app.kubernetes.io/name: prometheus
      app.kubernetes.io/part-of: prometheus-ams
    name: prometheus-ams
    namespace: ${NAMESPACE}
  spec:
    endpoints:
    - interval: 30s
      port: web
    selector:
      matchLabels:
        app.kubernetes.io/instance: ams
        app.kubernetes.io/name: prometheus
parameters:
- name: AUTHORIZE_URL
  value: https://api.openshift.com/api/accounts_mgmt/v1/cluster_registrations
- name: IMAGE
  value: quay.io/openshift/origin-telemeter
- name: IMAGE_TAG
  value: v4.0
- name: TELEMETER_SERVER_CPU_REQUEST
  value: 100m
- name: TELEMETER_SERVER_CPU_LIMIT
  value: "1"
- name: TELEMETER_SERVER_MEMORY_REQUEST
  value: 500Mi
- name: TELEMETER_SERVER_MEMORY_LIMIT
  value: 1Gi
- name: TELEMETER_FORWARD_URL
  value: ""
- name: PROMETHEUS_AMS_REMOTE_WRITE_PROXY_IMAGE
  value: quay.io/app-sre/observatorium-receive-proxy
- name: PROMETHEUS_AMS_REMOTE_WRITE_PROXY_VERSION
  value: 14e844d
- name: PROMETHEUS_AMS_IMAGE
  value: quay.io/prometheus/prometheus
- name: PROMETHEUS_AMS_IMAGE_TAG
  value: v2.12.0
- name: PROMETHEUS_AMS_CPU_REQUEST
  value: "0"
- name: PROMETHEUS_AMS_CPU_LIMIT
  value: "0"
- name: PROMETHEUS_AMS_MEMORY_REQUEST
  value: "0"
- name: PROMETHEUS_AMS_MEMORY_LIMIT
  value: "0"
